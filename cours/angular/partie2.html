<!doctype html>
<html lang="fr">
  <head>
    <meta charset="utf-8" />
    <title>Angular</title>

    <link rel="stylesheet" href="../assets/global.css" />

    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/reveal.js/dist/reveal.css"
    />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/reveal.js/dist/theme/white.css"
      id="theme"
    />

    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/highlight.js/styles/github.min.css"
    />

    <style>
      .reveal pre code {
        font-size: 0.9em;
      }

      section {
        font-size: 0.7em;
      }
    </style>

    <script>
      class AngularPlanList extends HTMLElement {
        static get observedAttributes() {
          return ["completed"];
        }

        constructor() {
          super();
          this.attachShadow({ mode: "open" });
          this.render();
        }

        attributeChangedCallback() {
          this.render();
        }

        get completed() {
          return Number(this.getAttribute("completed")) || 0;
        }

        render() {
          let remaining = this.completed;

          const mark = (label) => {
            if (remaining > 0) {
              remaining--;
              return `${label} <span class="check">‚úÖ</span>`;
            }
            if (remaining === 0) {
              remaining--;
              return `${label} <span class="check">üîÑÔ∏è</span>`;
            }
            return label;
          };

          this.shadowRoot.innerHTML = `
          <style>
            :host {
             text-align: start;
            }

            .check {
              font-size: 0.8em;
              margin-left: 8px;
              color: green;
            }
          </style>


              <ol>
                <li>${mark(
                  "Cr√©ation premier projet, cli, structure, fichiers de conf",
                )}</li>

                <li>Composants
                  <ul>
                    <li>${mark("Base")}</li>
                    <li>${mark("Data binding")}</li>
                    <li>${mark("Control flow")}</li>
                    <li>${mark("Les signaux")}</li>
                    <li>${mark("Input/output")}</li>
                  </ul>
                </li>


                <li>Services
                  <ul>
                    <li>${mark("Base")}</li>
                    <li>${mark("Http")}</li>
                    <li>${mark("Intercepteur")}</li>
                  </ul>
                </li>

                <li>Routage
                  <ul>
                    <li>${mark("Base")}</li>
                    <li>${mark("Controle d'acc√®s")}</li>
                  </ul>
                </li>


                <li>${mark("Directives")}</li>
                <li>${mark("Pipes")}</li>

                <li>${mark("Formulaires")}</li>
                <li>${mark("Angular material")}</li>
                <li>${mark("Angular < 21 && 16")}</li>

                <li>Tests unitaires
                  <ul>
                    <li>${mark("Kesako")}</li>
                    <li>${mark("Test de composants, de services")}</li>
                  </ul>
                </li>
              </ol>
          `;
        }
      }

      customElements.define("app-plan", AngularPlanList);
    </script>
  </head>

  <body>
    <div class="reveal">
      <div class="slides">
        <section data-background-image="../assets/fond-bienvenue.png">
          <h1 style="margin-top: 1.5em; margin-bottom: 0.8em">
            Services - HTTP
          </h1>
          <div style="display: flex; justify-content: center; padding: 0">
            <app-plan completed="7" style="font-size: 0.4em"></app-plan>
          </div>
        </section>

        <section data-background-image="../assets/fond-blanc.png">
          <h2>Service HTTP</h2>
          <p>C'est un service pour communiquer avec un serveur</p>
          <pre><code class="language-ts">@Injectable({ providedIn: 'root' })
export class UserService {
  constructor(private http: HttpClient) {}

  getUsers() {
    return this.http.get&lt;User[]&gt;('/api/users');
  }
}</code></pre>

          <pre><code class="language-ts">//main.ts
bootstrapApplication(AppComponent, {
  providers: [
    provideHttpClient() // Fournit HttpClient dans l'application
  ]
});</code></pre>
          <ul>
            <li>Marche via provideHttpClient() dans main.ts</li>
            <li>Utilise RxJS (Observables) pour les appels asynchrones</li>
            <li>Supporte les requ√™tes GET, POST, PUT, DELETE, etc.</li>
            <li>G√®re les en-t√™tes, les param√®tres, les erreurs, etc.</li>
          </ul>
        </section>

        <section data-background-image="../assets/fond-blanc.png">
          <h2>RxJS</h2>
          <ul>
            <li>C'est un library pour la programmation r√©active</li>
            <ul>
              <li>G√©rer des flux de donn√©es asynchrones</li>
            </ul>
            <li>Historique en Angular (depuis le d√©but)</li>
            <li class="difficulty-of-death-lite">
              Pas simple √† ma√Ætriser !!!!!!!!!!!!!!
            </li>
            <li style="margin-top: 0.3em">Mais pour le moment pas le choix</li>
            <ul>
              <li>L'API HTTP Angular retourne des Observables</li>
              <li>Appel http en parrall√®le a la suite...</li>
              <li>Programmation r√©active avanc√©e</li>
            </ul>
          </ul>
        </section>

        <section
          data-background-image="../assets/fond-blanc.png"
          style="zoom: 0.9"
        >
          <h3>Les concepts cl√©s</h3>

          <ul>
            <li>Observable : source de donn√©es dans le temps</li>
            <li>Observer : consomme les donn√©es</li>
            <li>Subscription : lien entre les deux</li>
          </ul>

          <pre><code class="language-ts">// Cr√©er un observable qui √©met 3 valeurs puis se termine
const observable = new Observable(subscriber => {
  subscriber.next(1); // √âmettre des valeurs
  subscriber.next(2);
  subscriber.next(3); 
  subscriber.complete(); // Indique la fin de l'√©mission
});

// S'abonner √† l'observable pour consommer les valeurs
observable.subscribe({
  next: value => console.log(value),            // G√©rer chaque valeur √©mise
  error: err => console.error('Erreur :', err), // G√©rer les erreurs
  complete: () => console.log('Termin√©')        // G√©rer la fin de l'√©mission
});

// Sortie attendue :
// 1
// 2
// 3
// Termin√©</code></pre>
        </section>

        <section data-background-image="../assets/fond-blanc.png">
          <h3>Les op√©rateurs</h3>

          <ul>
            <li>
              De plusieurs types : cr√©ation, transformation, filtrage,
              combinaison
            </li>
            <li>Utilis√©s avec la m√©thode pipe() des observables</li>
            <li>
              Permettent de composer des op√©rations sur les flux de donn√©es
            </li>
            <li>Exemples courants :</li>
            <ul>
              <li>map : transformer les valeurs</li>
              <li>filter : filtrer les valeurs</li>
            </ul>
          </ul>
          <pre><code class="language-ts">of(1, 2, 3, 4)                                 // Observable qui √©met 1, 2, 3, 4
.pipe(                                         // Appliquer des op√©rateurs avec pipe()
  filter(n => n % 2 === 0),                    // Garder que les nombres pairs
  map(n => n * 10)                             // Multiplier chaque nombre par 10
)
.subscribe(value => console.log(value));       // Consommer les valeurs transform√©es
                                                // Avant l'appel √† subscribe, rien ne se passe !
// Sortie attendue :
// 20
// 40</code></pre>
        </section>

        <section data-background-image="../assets/fond-blanc.png">
          <h3>RxJS ‚Äî Fonctions les plus utilis√©es</h3>

          <table class="compact-table">
            <colgroup>
              <col style="width: 10%" />
              <col style="width: 10%" />
              <col style="width: 40%" />
              <col style="width: 40%" />
            </colgroup>

            <thead>
              <tr>
                <th>Fonction</th>
                <th>Cat√©gorie</th>
                <th>R√¥le</th>
                <th>Exemple</th>
              </tr>
            </thead>

            <tbody>
              <tr>
                <td>of</td>
                <td>Creation</td>
                <td>Cr√©er un observable √† partir de valeurs</td>
                <td>
                  <pre><code class="language-ts">of(1, 2, 3)</code></pre>
                </td>
              </tr>

              <tr>
                <td>from</td>
                <td>Creation</td>
                <td>Cr√©er un observable depuis un tableau ou une promesse</td>
                <td>
                  <pre><code class="language-ts">from([10, 20, 30])</code></pre>
                </td>
              </tr>

              <tr>
                <td>map</td>
                <td>Transformation</td>
                <td>Transformer les valeurs</td>
                <td>
                  <pre><code class="language-ts">map(x => x * 2)</code></pre>
                </td>
              </tr>

              <tr>
                <td>filter</td>
                <td>Filtering</td>
                <td>Filtrer les valeurs</td>
                <td>
                  <pre><code class="language-ts">filter(x => x > 10)</code></pre>
                </td>
              </tr>

              <tr>
                <td>tap</td>
                <td>Utility / Side effects</td>
                <td>Effets de bord (logs, debug)</td>
                <td>
                  <pre><code class="language-ts">tap(value => console.log(value))</code></pre>
                </td>
              </tr>

              <tr>
                <td>switchMap</td>
                <td>Transformation</td>
                <td>Changer de flux (HTTP, recherche)</td>
                <td>
                  <pre><code class="language-ts">switchMap(v => this.service.search(v))</code></pre>
                </td>
              </tr>

              <tr>
                <td>forkJoin</td>
                <td>Combination</td>
                <td>
                  Appeler plusieurs WS en parall√®le et attendre tous les
                  r√©sultats
                </td>
                <td>
                  <pre><code class="language-ts">forkJoin([this.wsA(), this.wsB()])</code></pre>
                </td>
              </tr>

              <tr>
                <td>subscribe</td>
                <td>Subscription</td>
                <td>D√©marrer l'ex√©cution et consommer les valeurs</td>
                <td>
                  <pre><code class="language-ts">subscribe(value => console.log(value))</code></pre>
                </td>
              </tr>

              <tr>
                <td>unsubscribe</td>
                <td>Subscription</td>
                <td>Arr√™ter l'ex√©cution et lib√©rer les ressources</td>
                <td>
                  <pre><code class="language-ts">subscription.unsubscribe()</code></pre>
                </td>
              </tr>

              <tr>
                <td>takeUntil</td>
                <td>Subscription</td>
                <td>
                  Se d√©sabonner automatiquement √† la r√©ception d'un signal
                </td>
                <td>
                  <pre><code class="language-ts">takeUntil(this.destroy$)</code></pre>
                </td>
              </tr>
            </tbody>
          </table>
        </section>

        <section data-background-image="../assets/fond-blanc.png">
          <h3>Cas d'utilisation ‚Äî HTTP</h3>

          <p>En Angular, les appels HTTP retournent des observables</p>

          <pre><code class="language-ts">
@Injectable({ providedIn: 'root' })
export class UserService {
  constructor(private http: HttpClient) {}

  getUsers() {
    return this.http.get&lt;User[]&gt;('/api/users');
  }
}
  </code></pre>

          <pre><code class="language-ts">// Dans un composant ou un autre service
this.userService.getUsers().subscribe(users => {
  this.users = users;
});
  </code></pre>
          <ul>
            <li>L'appel HTTP n'est effectu√© qu'√† l'abonnement (subscribe)</li>
            <li>
              Complete automatique apr√®s la premi√®re valeur (pas de fuite
              m√©moire)
            </li>
          </ul>
        </section>

        <section data-background-image="../assets/fond-blanc.png">
          <h3>Exemple 1: Appels en parall√®le</h3>
          <p>
            J'appelle 2 WS en parall√®le et j'attends les 2 r√©sultats avant de
            continuer : forkJoin
          </p>
          <pre><code class="language-ts">@Injectable({ providedIn: 'root' })
export class UserService {
  private http = inject(HttpClient);

  getContratsEtFactures(userId: number) {
    return forkJoin({
      contracts: this.http.get&lt;Contract[]&gt;(`/api/contracts?userId=${userId}`),
      invoices: this.http.get&lt;Invoice[]&gt;(`/api/invoices?userId=${userId}`)
    });
  }
}</code></pre>

          <pre><code class="language-ts">this.userService.getContratsEtFactures(123).subscribe(({ contracts, invoices }) => {
  this.contracts = contracts;
  this.invoices = invoices;
});</code></pre>
        </section>

        <section data-background-image="../assets/fond-blanc.png">
          <h3>Exemple 2: Appels en s√©quentiel</h3>
          <p>
            J'appelle un WS et le resultat de l'appel sert √† appeler 2 WS en
            parall√®le
          </p>
          <pre><code class="language-ts">@Injectable({ providedIn: 'root' })
export class UserService {
  private http = inject(HttpClient);

  getInvoices(username: string) {
    return this.http.get&lt;User&gt;(`/api/users?name=${username}`).pipe(
      switchMap(user =>this.http.get&lt;Invoice[]&gt;(`/api/invoices?userId=${user.id}`))
    );
  }
}</code></pre>

          <pre><code class="language-ts">this.userService.getInvoices('John').subscribe(invoices => {
  this.invoices = invoices;
});</code></pre>
        </section>

        <section
          data-background-image="../assets/fond-blanc.png"
          style="zoom: 0.8"
        >
          <h3>Finalement c'est pas si dur ?</h3>
          <p>
            Exemple: j'appelle un WS et le resultat de l'appel sert √† appeler 2
            WS en parall√®le + j'ai des filtres + du logging + du mapping + des
            erreurs
          </p>

          <div class="col-2">
            <pre
              style="height: 650px"
            ><code class="language-ts" data-line-numbers="5-31">@Injectable({ providedIn: 'root' })
export class UserService {
  private http = inject(HttpClient);

  getDashboard(username: string) {
    return this.http.get&lt;User&gt;(`/api/users?name=${username}`).pipe(
      tap(user =&gt; console.log('[User]', user)),
      filter(user =&gt; user.active === true),
      switchMap(user =&gt;
        forkJoin({
          contracts: this.http.get&lt;Contract[]&gt;(`/api/contracts?userId=${user.id}`),
          invoices: this.http.get&lt;Invoice[]&gt;(`/api/invoices?userId=${user.id}`)
        }).pipe(
          tap(({ contracts, invoices }) =&gt; console.log('[Raw]', { contracts, invoices })),
          map(({ contracts, invoices }) =&gt; ({
            userId: user.id,
            username: user.name,
            contractsCount: contracts.length,
            unpaidInvoices: invoices.filter(i =&gt; i.status === 'UNPAID'),
            totalUnpaid: invoices
              .filter(i =&gt; i.status === 'UNPAID')
              .reduce((sum, i) =&gt; sum + i.amount, 0)
          }))
        )
      ),
      catchError(err =&gt; {
        console.error('[Dashboard error]', err);
        return throwError(() =&gt; new Error('Impossible de charger le dashboard'));
      })
    );
  }
}</code></pre>

            <pre><code class="language-ts">// Dans un composant ou un autre service
              
              
              
              
              
              
              
              
              
this.userService.getDashboard('John').subscribe({
  next: dashboard =&gt; {
    this.dashboard = dashboard;
  },
  error: err =&gt; {
    this.errorMessage = err.message;
  }
});

// Et du coup si ca marche pas, on fait quoi ?
// Les premieres fois tr√®s concr√®tement : mouchoir 



</code></pre>
          </div>
        </section>

        <section data-background-image="../assets/fond-blanc.png">
          <h2>Service HTTP : Observable</h2>
          <pre
            style="height: 550px"
          ><code class="language-ts">import { Injectable, inject } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable } from 'rxjs';

export type User = { id: number; name: string };

@Injectable({ providedIn: 'root' })
export class UsersApi {
  private http = inject(HttpClient);

  // un GET
  list(): Observable&lt;User[]&gt; {
    return this.http.get&lt;User[]&gt;('/api/users');
  }

  // un POST
  create(user: Partial&lt;User&gt;): Observable&lt;User&gt; {
    return this.http.post&lt;User&gt;('/api/users', user);
  }

  // un DELETE
  delete(userId: number): Observable&lt;void&gt; {
    return this.http.delete&lt;void&gt;(`/api/users/${userId}`);
  }

  // etc
}</code></pre>
        </section>

        <section data-background-image="../assets/fond-blanc.png">
          <h2>Lien avec le composant en Angular 21</h2>
          <p>Le mieux c'est d'utiliser les interop Signals / Observables</p>

          <pre><code class="language-ts" data-line-numbers="11">@Component({
  selector: 'app-root',
  template: `
    @for (user of users(); track user.id) {
      {{ user.name }}
    }
  `
})
export class AppComponent {
  private api = inject(UsersApi);
  users = toSignal(this.api.list(), { initialValue: [] }); // transformation Observable ‚Üí Signal
}</code></pre>
        </section>

        <section data-background-image="../assets/fond-blanc.png">
          <h2>Interop : Signal ‚Üí Observable (toObservable)</h2>
          <p>
            Utile quand tu veux r√©utiliser un flux RxJS (operators) √† partir
            d'un signal
          </p>
          <pre><code class="language-ts" data-line-numbers="13">@Component({
  selector: 'app-search',
  standalone: true,
  template: `
    <input [value]="term()" (input)="term.set(($event.target as HTMLInputElement).value)" />
    <p>R√©sultats : {{ results().length }}</p>
  `
})
export class SearchComponent {
  private api = inject(SearchApi);

  term = signal('');
  private term$ = toObservable(this.term);

  results = toSignal(this.api.search(this.term$), { initialValue: [] });
}</code></pre>
        </section>

        <section
          data-background-image="../assets/fond-blanc.png"
          style="zoom: 0.95"
        >
          <h2>TP12</h2>
          <ul>
            <li>Ajouter un titre "tp12" dans le HTML de Contenu</li>
            <li>Cr√©er un composant Posts et le mettre dans une Carte</li>
            <li>Cr√©er un service PostService</li>
            <li>
              Cr√©er (et typer) une m√©thode permettant d'appeler l'API GET
              https://jsonplaceholder.typicode.com/posts/1 dans post service.
              Afficher le resultat proprement dans Posts (cr√©er un composant
              detail-post qui prend un Post en ent√©e)
            </li>
            <li>
              Cr√©er (et typer) une autre m√©thode permettant d'appeler l'API
              https://jsonplaceholder.typicode.com/posts/1 et l'API
              https://jsonplaceholder.typicode.com/posts/1/comments en
              parall√®le. Afficher le resultat proprement dans Posts
            </li>
            <li>
              Cr√©er (et typer) une autre m√©thode permettant d'appeler l'API
              https://jsonplaceholder.typicode.com/posts/1 et l'API
              https://jsonplaceholder.typicode.com/posts/1/comments en
              s√©quentiel. Afficher le resultat proprement dans Posts
            </li>
            <li>
              Les autres types de m√©thodes POST, PATCH, DELETE, seront utilis√©
              dans d'autres exemples
            </li>
          </ul>
        </section>

        <section data-background-image="../assets/fond-bienvenue.png">
          <h1 style="margin-top: 1.5em; margin-bottom: 0.8em">
            Services - Intercepteur
          </h1>
          <div style="display: flex; justify-content: center; padding: 0">
            <app-plan completed="8" style="font-size: 0.4em"></app-plan>
          </div>
        </section>

        <section
          data-background-image="../assets/fond-blanc.png"
          style="zoom: 0.9"
        >
          <h2>Intercepteur HTTP</h2>
          <ul>
            <li>
              Intercepte les requ√™tes HTTP sortantes et les r√©ponses entrantes
            </li>
            <ul>
              <li>Ajouter des en-t√™tes (auth, logs)</li>
              <li>G√©rer les erreurs globales</li>
              <li>Modifier les r√©ponses (caching, transformation)</li>
            </ul>
            <li>Fonctionne comme un middleware</li>
            <ul>
              <li>req represente la requ√™te HTTP entrante (readonly)</li>
              <li>
                next sert a passer la requ√™te au prochain intercepteur ou au
                backend
              </li>
            </ul>
          </ul>
          <pre><code class="language-ts">// mon-super-intercepteur.ts
export function monSuperIntercepteur(req: HttpRequest&lt;unknown&gt;,next: HttpHandlerFn): Observable&lt;HttpEvent&lt;unknown&gt;&gt; {
// On peut modifier la requ√™te ici
  return next(req).pipe(
    tap((event) => { /* On peut inspecter ou modifier la r√©ponse ici */ }),
  );
}</code></pre>

          <pre><code class="language-ts">
//main.ts
bootstrapApplication(AppComponent, {
  providers: [provideHttpClient(withInterceptors([monSuperIntercepteur]))],
});</code></pre>
        </section>

        <section data-background-image="../assets/fond-blanc.png">
          <h2>Intercepteur HTTP: Exemple 1</h2>
          <p>Modifier la requ√™te avant qu'elle soit envoy√©e</p>
          <pre><code class="language-ts">export function authInterceptor(req: HttpRequest&lt;unknown&gt;, next: HttpHandlerFn) {
  const authToken = inject(AuthService).getAuthToken();
  const newReq = req.clone({ headers: req.headers.append('X-Authentication-Token', authToken) });
  return next(newReq);
}
          </code></pre>
          <ul>
            <li>
              Possibilit√© d'injecter des services
              <br />(Mais pas partout, il faut √™tre dans un contexte
              d'injection)
            </li>
            <li>Pour modifier la requ√™te, il faut la cloner (immutable)</li>
          </ul>
        </section>

        <section data-background-image="../assets/fond-blanc.png">
          <h2>Intercepteur HTTP: Exemple 2</h2>
          <p>Agir sur la reponse</p>
          <pre><code class="language-ts">export function loggingInterceptor(req: HttpRequest&lt;unknown&gt;, next: HttpHandlerFn) {
  console.log('Request sent:', req);
  return next(req).pipe(
    tap((event) => {
        if (event instanceof HttpResponse) {
          console.log('Response received:', event);
        }
      }
    ),
  );</code></pre>
          <ul>
            <li>Utile pour le logging ou le debugging</li>
            <li>Ne pas modifier la r√©ponse directement</li>
          </ul>
        </section>

        <section data-background-image="../assets/fond-blanc.png">
          <h2>TP13</h2>
          <ul>
            <li>
              Cr√©er un intercepteur qui ajoute, dans chaque appel REST, le
              header "AUTHENT" avec la valeur "toto".
            </li>

            <li>Ajouter un titre "TP13" dans le HTML de Contenu</li>

            <li>
              Cr√©er un composant PostsAuthentifie et le mettre dans une carte.
              Comme dans le TP pr√©c√©dent, ce composant doit appeler l'API
              https://jsonplaceholder.typicode.com/posts/1. √Ä la diff√©rence que
              cet appel doit √™tre fait lorsque l'utilisateur clique sur un
              bouton "Go".
            </li>

            <li>
              Cr√©er un composant Login et le mettre dans une carte. Y ajouter un
              champ email, un champ "mot de passe" (type password) et un bouton
              "Connexion".
            </li>

            <li>
              Au clic sur le bouton "Connexion", le login/mot de passe est
              encod√© en Base64 et stock√© dans un nouveau service
              Authentification.
            </li>

            <li>
              Faire en sorte que le header "AUTHENT" soit ajout√© √† chaque appel
              REST avec cette valeur.
            </li>
          </ul>
        </section>

        <section data-background-image="../assets/fond-bienvenue.png">
          <h1 style="margin-top: 1.5em; margin-bottom: 0.8em">Routage</h1>
          <div style="display: flex; justify-content: center; padding: 0">
            <app-plan completed="9" style="font-size: 0.4em"></app-plan>
          </div>
        </section>

        <section data-background-image="../assets/fond-blanc.png">
          <h2>C'est quoi ?</h2>
          <p>
            Le routeur Angular permet de g√©rer la navigation entre diff√©rentes
            vues (composants) dans une application SPA
            <br />Une route est un objet qui d√©crit quoi afficher pour un chemin
            d'URL
          </p>
          <ul>
            <li style="color: rgb(126, 125, 125)">
              Rappel: SPA = Single Page Application = une seule page html
            </li>
            <li>Encore un concept bien puissant :</li>
            <ul>
              <li>Routage de composant</li>
              <li>Sous-routes : insertion de composant dans un autre</li>
              <li>Lazy loading : chargement √† la demande</li>
              <li>Param√®tres dans l'URL</li>
              <li>Controle d'acc√®s (guards)</li>
              <li>Chargement de donn√©es avant l'affichage (resolvers)</li>
            </ul>
          </ul>
        </section>

        <section data-background-image="../assets/fond-blanc.png">
          <h3>D√©clarer des routes</h3>
          <p>Dans des fichiers *.routes.ts (ex: app.routes.ts)</p>

          <pre><code class="language-ts">// app.routes.ts
import { Routes } from '@angular/router';
import { HomePage } from './home/home-page';
import { AdminPage } from './admin/admin-page';

export const routes: Routes = [
  { path: '', component: HomePage },
  { path: 'admin', component: AdminPage },
  { path: 'user', component: UserPage },
];</code></pre>

          <ul>
            <li>Visiter / affiche HomePage</li>
            <li>Visiter /admin affiche AdminPage</li>
          </ul>
        </section>

        <section data-background-image="../assets/fond-blanc.png">
          <h3>Brancher le router</h3>
          <p>Avec provideRouter(routes) au bootstrap</p>

          <pre><code class="language-ts">import { ApplicationConfig } from '@angular/core';
import { provideRouter } from '@angular/router';
import { routes } from './app.routes';

export const appConfig: ApplicationConfig = {
  providers: [
    provideRouter(routes),
  ],
};</code></pre>

          <ul>
            <li>
              On peut (et doit pour une vrai application) avoir plusieurs
              fichiers de routes
            </li>
            <li>
              Mais ici on en importe tjs un seul, qui regroupe toutes les routes
            </li>
            <li>
              Il faut voir ca comme un arbre de routes, a cot√© des composants et
              services
            </li>
          </ul>
        </section>

        <section data-background-image="../assets/fond-blanc.png">
          <h3>Naviguer dans l'application (1)</h3>
          <p>Avec la directive routerLink dans les templates</p>
          <pre><code class="language-ts">&lt;a [routerLink]="['/user', userId()]"&gt;Voir le profil&lt;/a&gt; // Property binding</code></pre>
          <pre><code class="language-ts">&lt;a routerLink="/admin"&gt;Aller √† l'admin&lt;/a&gt; // Lien statique</code></pre>
          <ul>
            <li>
              Le tableau pass√© √† routerLink est concat√©n√© pour former le path
            </li>
            <li>Utile pour les routes avec param√®tres (ex: /user/123)</li>
          </ul>
        </section>

        <section data-background-image="../assets/fond-blanc.png">
          <h3>Naviguer dans l'application (2)</h3>
          <p>Avec le service Router dans le code TypeScript</p>
          <pre><code class="language-ts" data-line-numbers="5-9">import { Router } from '@angular/router';

@Component({ selector: 'app-some', template: `` })
export class SomeComponent {
  private router = inject(Router);

  goToUserProfile(userId: string) {
    this.router.navigate(['/user', userId]);
  }
}</code></pre>
          <ul>
            <li>
              Utile pour naviguer en r√©ponse √† une action utilisateur (ex:
              bouton)
            </li>
            <li>
              Permet de construire dynamiquement le chemin (avec param√®tres)
            </li>
          </ul>
        </section>

        <section
          data-background-image="../assets/fond-blanc.png"
          style="zoom: 0.9"
        >
          <h3>Route params : URL dynamiques</h3>
          <p>Param√®tres avec <code>:</code> (ex: <code>user/:id</code>)</p>

          <pre><code class="language-ts" data-line-numbers="5">import { Routes } from '@angular/router';
import { UserProfile } from './user-profile/user-profile';

export const routes: Routes = [
  { path: 'user/:id', component: UserProfile }, // Exemples : /user/leeroy, /user/jenkins
];</code></pre>

          <pre><code class="language-ts" data-line-numbers="4-9">// Dans UserProfile component
@Component({ selector: 'app-user-profile', template: ``})
export class UserProfile {
  // Option 1: avec snapshot (ne r√©agit pas aux changements de param√®tre)
  userId = toSignal(inject(ActivatedRoute).params.pipe(map(params =&gt; params['id'])));

  // Option 2: avec withComponentInputBinding
  // il faut mettre provideRouter(appRoutes, withComponentInputBinding()) dans main.ts
  id = input();
}</code></pre>

          <ul>
            <li>
              Permet de cr√©er des routes dynamiques (ex: profil utilisateur,
              d√©tails produit)
            </li>
            <li>
              R√©cup√©ration des param√®tres via ActivatedRoute ou
              withComponentInputBinding
            </li>
          </ul>
        </section>

        <section data-background-image="../assets/fond-blanc.png">
          <h3>Ordre des routes : ‚Äúfirst match wins‚Äù</h3>
          <p>
            Le router prend la premi√®re route qui match : la sp√©cificit√© compte
          </p>

          <pre><code class="language-ts">export const routes: Routes = [
  { path: '', component: HomeComponent },
  { path: 'toto', redirectTo: '' },                        // redirige /toto vers /
  { path: 'users/new', component: NewUserComponent },      // route sp√©cifique (priorit√© sur users/:id)
  { path: 'users/:id', component: UserDetailComponent },
  { path: 'users', component: UsersComponent },
  { path: '**', component: NotFoundComponent },            // match tout le reste
];</code></pre>
        </section>

        <section
          data-background-image="../assets/fond-blanc.png"
          style="zoom: 0.93"
        >
          <h3>Routes avanc√©es : children</h3>
          <div class="col-2">
            <pre><code class="language-ts">export const routes: Routes = [
  {
    path: 'product',
    component: ProductComponent,
    children: [
      { path: 'info', component: ProductInfoComponent },
      { path: 'reviews', component: ProductReviewsComponent },
    ],
  },
];</code></pre>

            <pre><code class="language-ts" data-line-numbers="7">
// Dans product.component.ts
@Component({
  selector: 'app-product',
  template: `
    &lt;h2&gt;Product Details&lt;/h2&gt;
    &lt;router-outlet&gt;&lt;/router-outlet&gt;
  `
})
</code></pre>
          </div>

          <ul>
            <li>
              Les routes enfants sont des routes qui s'appliquent √† un composant
              parent
            </li>
            <li>
              Le composant parent doit contenir un &lt;router-outlet&gt; pour
              afficher les enfants
            </li>
            <li>Permet de controler des vues imbriqu√©es</li>
            <li>
              Ici /product/info affiche ProductInfoComponent dans
              ProductComponent
            </li>
          </ul>
        </section>

        <section
          data-background-image="../assets/fond-blanc.png"
          style="zoom: 0.93"
        >
          <h3>Routes avanc√©es : children</h3>
          <div class="col-2">
            <pre><code class="language-ts">// app.routes.ts
export const routes: Routes = [
  {
    path: 'product',
    component: ProductComponent,
    loadChildren: () => import('./product/product.routes').then(m =&gt; m.productRoutes)
  },
];</code></pre>

            <pre><code class="language-ts" data-line-numbers="7">// product.routes.ts
export const productRoutes: Routes = [
  { path: 'info', component: ProductInfoComponent },
  { path: 'reviews', component: ProductReviewsComponent },
];
</code></pre>
          </div>

          <ul>
            <li>Permet de d√©couper les routes dans plusieurs fichiers</li>
            <li>
              Utile pour les routes avec beaucoup d'enfants ou des domaines
              fonctionnels distincts
            </li>
          </ul>
        </section>

        <section data-background-image="../assets/fond-blanc.png">
          <h3>Chargement : eager vs lazy</h3>
          <p>
            component = eager (bundle initial), loadComponent = lazy (import
            dynamique)
          </p>

          <pre><code class="language-ts">export const routes: Routes = [
  { path: 'main', loadComponent: () => import('./main/main-page').then(m => m.MainPage) },
  { path: 'login', component: LoginPage},
  { path: 'admin', loadChildren: () => import('./admin/admin.routes').then(m => m.adminRoutes) },
];</code></pre>

          <p>
            On ne veut pas charger tout le code de l'application au d√©marrage
            (avant authentitication de l'utilisateur par exemple)
          </p>
        </section>

        <section data-background-image="../assets/fond-blanc.png">
          <h2>TP14</h2>
          <p>
            Le but de ce TP est de cr√©er une route par TP que nous avons fait
            jusqu'√† pr√©sent, et d'avoir un menu dans le Header pour acc√©der aux
            diff√©rentes pages.
          </p>
          <ul>
            <li>
              Cr√©er un dossier pages sous app. Il repr√©sentera les diff√©rentes
              pages de notre application.
            </li>
            <li>
              Cr√©er une page par TP dans ce dossier (= un composant par TP).
              Migrer le contenu de chaque TP du composant Contenu vers les
              diff√©rentes pages de TP.
              <br />
              /!\ C'est le contenu HTML qui bouge : le code de tous nos
              composants d√©velopp√©s jusqu'√† pr√©sent reste dans le dossier
              features.
            </li>
            <li>Cr√©er une route par TP dans app.routes.ts.</li>
            <li>
              Ajouter des liens de navigation dans Header et faire en sorte de
              naviguer vers les diff√©rentes routes au clic sur ces liens.
            </li>
            <li>
              Le TP13 est particulier : il faudrait faire des sous-routes pour
              obliger l'utilisateur √† se connecter avant de lui permettre de
              r√©cup√©rer des posts authentifi√©s. Faire le job.
            </li>
          </ul>
        </section>

        <section data-background-image="../assets/fond-blanc.png">
          <h2>TP14</h2>
          <ul>
            <li>
              Ajouter withViewTransitions (voir
              <a
                href="https://angular.dev/guide/routing/route-transition-animations"
                >ici</a
              >).
            </li>
            <li>Cr√©er la page TP14.</li>
            <li>
              Faire un composant de s√©lection de posts (SelectionPostsPage) qui
              :
              <ul>
                <li>
                  affiche les posts via l'API
                  https://jsonplaceholder.typicode.com/posts
                </li>
                <li>
                  permet de s√©lectionner un post pour arriver sur une vue
                  permettant de visualiser un post donn√© (cr√©er le composant
                  DetailPostPage).
                </li>
              </ul>
            </li>
          </ul>
        </section>

        <section data-background-image="../assets/fond-bienvenue.png">
          <h1 style="margin-top: 1.5em; margin-bottom: 0.8em">
            Routage - Control d'acc√®s
          </h1>
          <div style="display: flex; justify-content: center; padding: 0">
            <app-plan completed="10" style="font-size: 0.4em"></app-plan>
          </div>
        </section>

        <section data-background-image="../assets/fond-blanc.png">
          <h2>Guards</h2>
          <p>
            Les guards sont des fonctions qui permettent de contr√¥ler l'acc√®s
            aux routes
            <a
              href="https://angular.dev/guide/routing/route-guards#route-guard-return-types"
              >voir ici</a
            >
          </p>
          <ul>
            <li>Impl√©mentent la logique d'autorisation</li>
            <li>D√©cident si une route peut √™tre activ√©e ou non</li>
            <li>
              Utilisent l'injection de d√©pendances pour acc√©der aux services
            </li>
          </ul>
          <pre><code class="language-ts">export function authGuard(): CanActivateFn {
  const authService = inject(AuthService);
  const router = inject(Router);
  return authService.isLoggedIn() ? true : router.parseUrl('/login');
}</code></pre>
          <pre><code class="language-ts">export const routes: Routes = [
  { path: 'admin', canActivate: [authGuard] },
  { path: 'login', component: LoginPage },
];</code></pre>
        </section>

        <section data-background-image="../assets/fond-blanc.png">
          <h2>TP15</h2>
          <ul>
            <li>Faire deux guards :</li>
            <ul>
              <li>
                Pour la route TP14, interdire l'acc√®s √† la route qui m√®ne au
                composant DetailPostPage si le post n'existe pas (par exemple
                /tp14/post/999 n'existe pas).
              </li>
              <li>
                Pour la route TP13, interdire l'acc√®s √† la page des posts si
                l'utilisateur ne s'est pas authentifi√©.
              </li>
            </ul>
          </ul>
        </section>

        <section data-background-image="../assets/fond-bienvenue.png">
          <h1 style="margin-top: 1.5em; margin-bottom: 0.8em">Directives</h1>
          <div style="display: flex; justify-content: center; padding: 0">
            <app-plan completed="11" style="font-size: 0.4em"></app-plan>
          </div>
        </section>

        <section
          style="zoom: 0.97"
          data-background-image="../assets/fond-blanc.png"
        >
          <h2>Directives</h2>
          <p>
            Les directives permettent de modifier le comportement ou la
            structure du DOM
          </p>
          <ul>
            <li>Un composant est une directive avec un template html</li>
            <li>Plusieurs type de directives</li>
            <li>Directive de type attribut</li>
          </ul>

          <pre><code class="language-html">
<div appHighlight></div>
  </code></pre>
          <pre><code class="language-ts">@Directive({
  selector: '[appHighlight]'
})
export class HighlightDirective {

  constructor(
    private el: ElementRef,
    private renderer: Renderer2
  ) {
    this.renderer.setStyle(this.el.nativeElement,'background-color','#ffff99');
  }
}</code></pre>
        </section>

        <section data-background-image="../assets/fond-bienvenue.png">
          <h1 style="margin-top: 1.5em; margin-bottom: 0.8em">Pipes</h1>
          <div style="display: flex; justify-content: center; padding: 0">
            <app-plan completed="12" style="font-size: 0.4em"></app-plan>
          </div>
        </section>

        <section
          style="zoom: 0.97"
          data-background-image="../assets/fond-blanc.png"
        >
          <h3>Pipes</h3>
          <p>
            Les pipes permettent de transformer des donn√©es directement dans les
            templates.
          </p>
          <div class="col-2">
            <div style="width: 419px">
              <strong>Pipes int√©gr√©s</strong>
              <pre><code class="language-html"><p>{{ today() | date:'dd/MM/yyyy' }}</p>
<p>{{ price() | currency:'EUR' }}</p>
<p>{{ user() | json }}</p></code></pre>
            </div>
            <div style="width: 619px">
              <strong>Pipes custom</strong>
              <pre><code class="language-html"><p>{{ username() | capitalize }}</p></code></pre>
              <pre><code class="language-ts">@Pipe({
  name: 'capitalize'
})
export class CapitalizePipe implements PipeTransform {
  transform(value: string): string {
    return value.charAt(0).toUpperCase() + value.slice(1);
  }
}</code></pre>
            </div>
          </div>
        </section>

        <section data-background-image="../assets/fond-bienvenue.png">
          <h1 style="margin-top: 1.5em; margin-bottom: 0.8em">Form</h1>
          <div style="display: flex; justify-content: center; padding: 0">
            <app-plan completed="13" style="font-size: 0.4em"></app-plan>
          </div>
        </section>

        <section data-background-image="../assets/fond-blanc.png">
          <h2>Formulaire</h2>
          <blockquote>
            "L'√©l√©ment HTML form repr√©sente une section du document contenant
            des contr√¥les interactifs permettant de soumettre des informations."
            <a
              href="https://developer.mozilla.org/fr/docs/Web/HTML/Reference/Elements/form"
              >*</a
            >
          </blockquote>

          <ul>
            <li>Saisie utilisateur structur√©e</li>
            <li>Validation c√¥t√© client</li>
            <li>Gestion de l'√©tat (valide, invalide, touched, dirty)</li>
            <li>Int√©gration forte avec TypeScript</li>
          </ul>
        </section>

        <section data-background-image="../assets/fond-blanc.png">
          <h3>Les deux approches Angular</h3>
          <ul>
            <li>Template-driven forms</li>
            <li>Reactive forms</li>
          </ul>

          <p>
            En contexte professionnel, on privil√©gie Reactive Forms
            <br />(en tout cas chez nous !)
          </p>

          <ul>
            <li>Code plus explicite</li>
            <li>Meilleure testabilit√©</li>
            <li>Logique c√¥t√© TypeScript</li>
          </ul>
        </section>

        <section data-background-image="../assets/fond-blanc.png">
          <h3>Qu'est-ce qu'un Reactive Form ?</h3>
          <p>
            Un Reactive Form est d√©fini enti√®rement en TypeScript √† l'aide
            d'objets immuables repr√©sentant l'√©tat du formulaire.
          </p>

          <ul>
            <li>FormControl : un champ</li>
            <li>FormGroup : un formulaire</li>
            <li>FormArray : une liste dynamique de champs</li>
          </ul>
        </section>

        <section data-background-image="../assets/fond-blanc.png">
          <h3>Cr√©er un FormControl</h3>
          <p>Un champ avec une valeur initiale et des validateurs</p>

          <pre><code class="language-ts">import { FormControl, Validators } from '@angular/forms';

const emailControl = new FormControl('', [
  Validators.required,
  Validators.email,
]);</code></pre>
        </section>

        <section data-background-image="../assets/fond-blanc.png">
          <h3>Cr√©er un FormGroup</h3>
          <p>Un formulaire compos√© de plusieurs champs</p>

          <pre><code class="language-ts">import { FormGroup, FormControl, Validators } from '@angular/forms';

const loginForm = new FormGroup({
  email: new FormControl('', [Validators.required, Validators.email]),
  password: new FormControl('', Validators.required),
});</code></pre>
        </section>

        <section data-background-image="../assets/fond-blanc.png">
          <h3>Lier le formulaire au template</h3>
          <p>Connexion entre TypeScript et HTML</p>

          <pre><code class="language-html">&lt;form [formGroup]="loginForm"&gt;
  &lt;input type="email" formControlName="email"&gt;
  &lt;input type="password" formControlName="password"&gt;
&lt;/form&gt;</code></pre>

          <ul>
            <li>Utilisation de formGroup pour lier le formulaire</li>
            <li>Utilisation de formControlName pour chaque champ</li>
          </ul>
        </section>

        <section data-background-image="../assets/fond-blanc.png">
          <h3>Lire l'√©tat du formulaire</h3>
          <p>Chaque champ expose son √©tat</p>

          <table class="compact-table">
            <colgroup>
              <col style="width: 10%" />
              <col style="width: 40%" />
              <col style="width: 40%" />
            </colgroup>

            <thead>
              <tr>
                <th>Propri√©t√©</th>
                <th>Signification</th>
                <th>Exemple</th>
              </tr>
            </thead>

            <tbody>
              <tr>
                <td>valid</td>
                <td>valide ou non</td>
                <td>
                  <pre><code class="language-ts">this.loginForm.valid</code></pre>
                </td>
              </tr>

              <tr>
                <td>invalid</td>
                <td>invalide ou non</td>
                <td>
                  <pre><code class="language-ts">this.loginForm.invalid</code></pre>
                </td>
              </tr>

              <tr>
                <td>touched</td>
                <td>touch√© ou non</td>
                <td>
                  <pre><code class="language-ts">this.loginForm.controls.email.touched</code></pre>
                </td>
              </tr>

              <tr>
                <td>untouched</td>
                <td>non touch√©</td>
                <td>
                  <pre><code class="language-ts">this.loginForm.controls.email.untouched</code></pre>
                </td>
              </tr>

              <tr>
                <td>dirty</td>
                <td>modifi√© ou non</td>
                <td>
                  <pre><code class="language-ts">this.loginForm.controls.email.dirty</code></pre>
                </td>
              </tr>

              <tr>
                <td>pristine</td>
                <td>non modifi√©</td>
                <td>
                  <pre><code class="language-ts">this.loginForm.controls.email.pristine</code></pre>
                </td>
              </tr>

              <tr>
                <td>errors</td>
                <td>objet contenant les erreurs de validation</td>
                <td>
                  <pre><code class="language-ts">this.loginForm.controls.email.errors</code></pre>
                </td>
              </tr>

              <tr>
                <td>value</td>
                <td>valeur actuelle du champ ou du formulaire</td>
                <td>
                  <pre><code class="language-ts">this.loginForm.value</code></pre>
                </td>
              </tr>
            </tbody>
          </table>
        </section>

        <section data-background-image="../assets/fond-blanc.png">
          <h3>Validation des formulaires</h3>

          <ul>
            <li>Validators int√©gr√©s Angular</li>
            <ul>
              <li>required</li>
              <li>minLength / maxLength</li>
              <li>email</li>
              <li>pattern</li>
            </ul>
            <li>Possibilit√© de cr√©er des validateurs personnalis√©s</li>
          </ul>

          <pre><code class="language-ts">password: new FormControl('', [
  Validators.required,
  Validators.minLength(8),
]);</code></pre>
        </section>

        <section data-background-image="../assets/fond-blanc.png">
          <h3>R√©agir aux changements</h3>
          <p>Les formulaires exposent des observables RxJS</p>

          <pre><code class="language-ts">this.loginForm.valueChanges.subscribe(value => {
  console.log(value);
});

this.loginForm.statusChanges.subscribe(status => {
  console.log(status);
});</code></pre>
        </section>

        <section data-background-image="../assets/fond-blanc.png">
          <h3>Soumettre un formulaire</h3>

          <pre><code class="language-ts">onSubmit() {
  if (this.loginForm.valid) {
    console.log(this.loginForm.value);
  }
}</code></pre>

          <pre><code class="language-html">&lt;form [formGroup]="loginForm" (ngSubmit)="onSubmit()"&gt;
&lt;/form&gt;</code></pre>
        </section>

        <section data-background-image="../assets/fond-blanc.png">
          <h2>TP16</h2>
          <ul>
            <li>
              Modifier le code existant du TP9 (chiffre le plus grand) pour
              utiliser un formulaire r√©actif
            </li>
            <li>Pareil pour le composant Login</li>
          </ul>
        </section>

        <section data-background-image="../assets/fond-bienvenue.png">
          <h1 style="margin-top: 1.5em; margin-bottom: 0.8em">
            Angular material
          </h1>
          <div style="display: flex; justify-content: center; padding: 0">
            <app-plan completed="14" style="font-size: 0.4em"></app-plan>
          </div>
        </section>

        <section data-background-image="../assets/fond-blanc.png">
          <h2>Angular Material</h2>
          <ul>
            <li>
              Une lib cr√©e et maintenu par l'√©quipe Angular (Voir
              <a href="https://material.angular.dev/components/categories"
                >ici</a
              >)
            </li>
            <li>Plusieurs aspects pr√©sent</li>
            <ul>
              <li>Biblioth√®que de composant haut niveau pr√™ts √† l'emploi</li>
              <ul>
                <li>Impl√©mentation du design system material</li>
              </ul>
              <li>
                Un CDK (=des API plut√¥t bas niveau) pour construire et tester
                des composants
              </li>
            </ul>
          </ul>
        </section>

        <section data-background-image="../assets/fond-blanc.png">
          <h3>Pourquoi Angular Material ?</h3>

          <ul>
            <li>Concernant les composants haut niveau</li>
            <ul>
              <li>Gagner du temps sur l'UI</li>
              <li>Bon niveau d'accessibilit√© (a11y)</li>
              <li>Marche sur tout les navigateurs</li>
            </ul>
            <li>Concernant le CDK</li>
            <ul>
              <li>Top quand on a un design system impos√©</li>
              <li>Briques techniques sans design impos√©</li>
              <li>Gestion du focus, clavier et accessibilit√©</li>
              <li>Test Harness pour des tests robustes et maintenables</li>
            </ul>
          </ul>
        </section>

        <section data-background-image="../assets/fond-blanc.png">
          <h3>Installation</h3>

          <pre><code class="language-bash">ng add @angular/material</code></pre>

          <img src="../assets/material.png" alt="" />
          <p>
            Ici j'ai choisi Azure/Blue, il y en a plusieurs existant avec la
            possibilit√© custom des √©l√©ments (Voir
            <a href="https://material.angular.dev/guide/theming">ici</a>)
          </p>
        </section>

        <section data-background-image="../assets/fond-blanc.png">
          <h3>Premier exemple</h3>

          <pre><code class="language-ts">@Component({
  standalone: true,
  imports: [MatButtonModule],
  template: `<button mat-raised-button>OK</button>`
})
export class ExampleComponent {}</code></pre>

          <ul>
            <li>Pas oubli√© d'importer le composant</li>
            <li>Via son module (vestige des anciennes versions)</li>
          </ul>
        </section>

        <section data-background-image="../assets/fond-blanc.png">
          <h3>Composants Angular Material les plus utilis√©s</h3>

          <table class="compact-table">
            <thead>
              <tr>
                <th>Composant</th>
                <th>Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>MatButton</td>
                <td>
                  Boutons Material (primary, accent, warn, actions utilisateur)
                </td>
              </tr>
              <tr>
                <td>MatInput</td>
                <td>Champ de saisie texte int√©gr√© aux formulaires</td>
              </tr>
              <tr>
                <td>MatFormField</td>
                <td>
                  Conteneur de champs avec label, erreurs et accessibilit√©
                </td>
              </tr>
              <tr>
                <td>MatIcon</td>
                <td>Affichage d'ic√¥nes Material</td>
              </tr>
              <tr>
                <td>MatDialog</td>
                <td>Fen√™tres modales (confirmation, formulaire, alerte)</td>
              </tr>
              <tr>
                <td>MatTable</td>
                <td>Tableaux de donn√©es avec tri, pagination et filtres</td>
              </tr>
              <tr>
                <td>MatSnackBar</td>
                <td>Messages temporaires de notification</td>
              </tr>
            </tbody>
          </table>
        </section>

        <section data-background-image="../assets/fond-blanc.png">
          <h3>Angular Material + Reactive Forms</h3>

          <pre style="height: 600px"><code class="language-html">@Component({
  imports: [ReactiveFormsModule, MatFormFieldModule, MatInputModule, MatButtonModule],
  template: `
    &lt;form [formGroup]="form" (ngSubmit)="submit()"&gt;
      &lt;mat-form-field&gt;
        &lt;mat-label&gt;Email&lt;/mat-label&gt;
        &lt;input matInput type="email" formControlName="email"/&gt;
      &lt;/mat-form-field&gt;

      &lt;button mat-raised-button color="primary" type="submit" [disabled]="form.invalid"&gt;
        Envoyer
      &lt;/button&gt;
    &lt;/form&gt;
  `
})
export class ExampleComponent {
  form = new FormGroup({
    email: new FormControl('', [
      Validators.required,
      Validators.email
    ])
  });

  submit() {
    console.log(this.form.value);
  }
}</code></pre>
        </section>

        <section data-background-image="../assets/fond-blanc.png">
          <h2>TP17</h2>
          <ul>
            <li>
              Modifier le composant Carte pour utiliser les
              <a href="https://material.angular.dev/components/card/overview"
                >cards</a
              >
              (ne pas supprimer le composant Carte : change le contenu)
            </li>
            <li>
              Utiliser le composant
              <a
                href="https://material.angular.dev/components/snack-bar/overview"
                >snak-bar</a
              >
              pour afficher un message apr√®s la connection sur la page de Login
            </li>
            <li>
              Modifier les formulaires de Login et de ChiffreLePlusGrand pour
              utiliser les
              <a href="https://material.angular.dev/components/input/overview"
                >input</a
              >
              et les
              <a
                href="https://material.angular.dev/components/form-field/overview"
                >form-field</a
              >
              d'angular material
            </li>
            <li>
              Utiliser la
              <a
                href="https://material.angular.dev/components/checkbox/overview"
                >checkbox</a
              >
              dans les input de type checkbox
            </li>
            <li>
              Utiliser les
              <a href="https://material.angular.dev/components/select/overview"
                >select</a
              >
            </li>
            <li>
              Utiliser les
              <a href="https://material.angular.dev/components/button/overview"
                >boutons</a
              >
            </li>
          </ul>
        </section>

        <section data-background-image="../assets/fond-bienvenue.png">
          <h1 style="margin-top: 1.5em; margin-bottom: 0.8em">
            Angular (avant Angular 16 & 21)
          </h1>
          <div style="display: flex; justify-content: center; padding: 0">
            <app-plan completed="15" style="font-size: 0.4em"></app-plan>
          </div>
        </section>

        <section data-background-image="../assets/fond-blanc.png">
          <h2>Angular (avant Angular 16 & 21)</h2>

          <ul>
            <li>Architecture bas√©e sur NgModules</li>
            <ul>
              <li>Pas de standalone components</li>
            </ul>
            <li>Pas de signals</li>
            <ul>
              <li>Change detection avec zonejs</li>
            </ul>
          </ul>
        </section>

        <section data-background-image="../assets/fond-blanc.png">
          <h3>Architecture centrale : NgModules</h3>

          <p>Toute application Angular √©tait organis√©e autour des modules</p>
          <ul>
            <li>D√©clarer les composants, directives, pipes</li>
            <li>G√©rer les imports</li>
            <li>G√©rer les exports</li>
            <li>G√©rer l'injection de d√©pendances</li>
          </ul>
          <img
            src="../assets/archi_angular_old.png"
            alt=""
            style="height: 400px"
          />
        </section>

        <section data-background-image="../assets/fond-blanc.png">
          <h3>Les modules</h3>

          <p>Les composants doivent √™tre d√©clar√©s dans un module.</p>

          <div class="col-2">
            <pre><code class="language-ts">@Component({
  selector: 'app-home',
  templateUrl: './home.component.html'
})
export class HomeComponent {
  title = 'Home';

}</code></pre>

            <pre><code class="language-ts">@NgModule({
  declarations: [HomeComponent], // Il faut declarer tout les composants du module 
  imports: [
    CommonModule
  ],
  providers: [
    HomeService,                 // Provider disponible pour et que pour module
  ],
  exports: [HomeComponent]       // Et choisir ceux qu'on exporte en dehors du module 
})
export class HomeModule {}</code></pre>
          </div>

          <ul>
            <li>Impossible de les utiliser sans les d√©clarer dans un Module</li>
            <li>
              Pour le moment il y a encore la notions de modules dans les
              <span class="kiki">tests</span>
            </li>
          </ul>
        </section>

        <section data-background-image="../assets/fond-blanc.png">
          <h3>Pas de Signals, pas d'inject</h3>

          <p>Tout repose sur RxJS: il y en a partout</p>

          <div class="col-2">
            <pre><code class="language-ts">@Component({
  selector: 'app-home',
  template: `<h1>{{titre | async}}</h1>`
})
export class HomeComponent {
  titre: Observable&lt;string&gt;;

  constructor(private homeService: HomeService){}

}</code></pre>
            <pre><code class="language-ts">@Component({
  selector: 'app-home',
  template: `<h1>{{titre}}</h1>`
})
export class HomeComponent {
  titre: string;

  constructor(private homeService: HomeService){
    homeService.getTitle()
      .pipe(takeUntilDestroyed())  // sinon fuite m√©moire, l'observable est pas kill
      .subscribe(titre => this.titre2 = titre);
  }

}</code></pre>
          </div>

          <ul>
            <li>
              M√©thode 1 avec le pipe async : g√©rer tout seul le kill de
              l'observable
            </li>
            <li>
              M√©thode 2 subscribe dans le composant: il faut faire attention au
              fuite m√©moire
            </li>
          </ul>
        </section>

        <section data-background-image="../assets/fond-blanc.png">
          <h3>Change Detection classique</h3>

          <p>Angular d√©tecte les changements automatiquement via la zone.js</p>

          <ul>
            <li>Change detection globale</li>
            <li>D√©clench√©e par √©v√©nements, timers, HTTP</li>
            <li>Peut √™tre co√ªteuse sur de grosses apps</li>
          </ul>
          <p class="col-2" style="justify-content: space-around">
            <img src="../assets/zone.png" alt="" style="height: 300px" />
            <img
              src="../assets/archi-signal.png"
              alt=""
              style="height: 300px"
            />
          </p>
        </section>

        <section data-background-image="../assets/fond-blanc.png">
          <h3>RxJS partout</h3>

          <p>RxJS est la pierre angulaire pour :</p>

          <ul>
            <li>HTTP</li>
            <li>Formulaires (valueChanges)</li>
            <li>Communication entre composants</li>
            <li>Gestion d'√©tat avanc√©e</li>
          </ul>

          <pre><code class="language-ts">this.http.get('/api/users')
  .subscribe(users => this.users = users);</code></pre>
        </section>

        <section data-background-image="../assets/fond-blanc.png">
          <h3>Limites et √† retenir</h3>

          <ul>
            <li>Pourquoi ca a √©volu√© ?</li>
            <ul>
              <li>Beaucoup de boilerplate</li>
              <li>NgModules complexes √† maintenir</li>
              <li>Change detection parfois co√ªteuse</li>
              <li>Mont√©e en complexit√© sur gros projets</li>
            </ul>
            <li>A retenir</li>
            <ul>
              <li>Angular 16 (standalone) et 21 (signals)</li>
              <li>Encore beaucoup utilis√©e</li>
              <li>M√©canisme de module utilis√© dans les tests</li>
            </ul>
          </ul>
        </section>

        <section data-background-image="../assets/fond-bienvenue.png">
          <h1 style="margin-top: 1.5em; margin-bottom: 0.8em">Tests Angular</h1>
          <div style="display: flex; justify-content: center; padding: 0">
            <app-plan completed="16" style="font-size: 0.4em"></app-plan>
          </div>
        </section>

        <section data-background-image="../assets/fond-blanc.png">
          <h3>Pourquoi tester ?</h3>
          <ul>
            <li>D√©tecter les bugs t√¥t</li>
            <li>Documenter le comportement attendu</li>
            <li>Refactorer sans peur</li>
            <li>Am√©liorer la qualit√© (contrats clairs)</li>
          </ul>
          <p>
            Ca peut sembler √©vider mais quand l'application grossi, c'est hyper
            utile de savoir tout les cas possible des composants
          </p>
          <p class="difficulty-of-death-lite">
            C'est un des endroits ou il faut √™tre le plus rigoureux
          </p>
        </section>

        <section
          data-background-image="../assets/fond-blanc.png"
          style="zoom: 0.95"
        >
          <h3>Approches et type de tests</h3>
          <p>La question est de savoir √©valuer le rapport co√ªt/qualit√©</p>
          <div class="col-2" style="justify-content: space-around">
            <img src="../assets/pyramide-tests.png" style="height: 300px" />
            <img src="../assets/trophy-tests.png" style="height: 300px" />
          </div>
          <table class="compact-table">
            <tbody>
              <tr>
                <td><strong>Tests statiques</strong></td>
                <td>
                  Analyser le code sans l'ex√©cuter (Type checking, formatage,
                  linting)
                </td>
              </tr>
              <tr>
                <td><strong>Tests unitaires</strong></td>
                <td>Tester un composant ou une fonction isol√©e</td>
              </tr>
              <tr>
                <td><strong>Tests d'int√©gration</strong></td>
                <td>
                  V√©rifier le fonctionnement de plusieurs composants ensemble
                </td>
              </tr>
              <tr>
                <td><strong>Tests end-to-end (E2E)</strong></td>
                <td>Simuler un parcours utilisateur complet</td>
              </tr>
            </tbody>
          </table>
        </section>

        <section data-background-image="../assets/fond-blanc.png">
          <h3>Stack par d√©faut (Angular CLI)</h3>
          <ul>
            <li>
              Runner de tests : Vitest (par d√©faut sur les nouveaux projets)
            </li>
            <li>API d'assertions : expect</li>
            <li>Mocks / spies : vi.fn(), vi.spyOn()</li>
            <li>Environnement DOM : jsdom</li>
          </ul>

          <pre><code class="language-bash">ng test</code></pre>
        </section>

        <section data-background-image="../assets/fond-blanc.png">
          <h3>Structure d'un test</h3>

          <ul>
            <li>describe = un ensemble de test</li>
            <li>it = un test = une intention clair de test</li>
            <li>
              expect = une assertion = je m'attend a ce que j'ai ceci ou cela
            </li>
            <li>Optionnel : structurer en given, when, then</li>
          </ul>

          <pre><code class="language-ts">describe('sum', () => {
  it('should be 5 when 2 is added to 3', () => {
    // Given
    const a = 2;
    const b = 3;

    // When
    const result = a + b;

    // Then
    expect(result).toBe(5);
  });
});</code></pre>
        </section>

        <section data-background-image="../assets/fond-blanc.png">
          <h3>TestBed : le "container" de tests Angular</h3>
          <p>
            TestBed permet de configurer un module de test : providers, imports,
            composants<br />(C'est pour ca qu'il faut savoir ce qu'est un
            module)
          </p>

          <pre><code class="language-ts">beforeEach(() => {
  TestBed.configureTestingModule({
    providers: [],
    imports: [],
  });
});</code></pre>
        </section>

        <section data-background-image="../assets/fond-blanc.png">
          <h3>Tester un service (DI + mocks)</h3>

          <div class="col-2" style="height: 550px">
            <pre><code class="language-ts">describe('UserService', () => {

  function setup(loggerMock: Logger) {
    await TestBed.configureTestingModule({
      providers: [
        { provide: Logger, useValue: loggerMock },
      ],
    });
    return TestBed.inject(UserService)
  }


  it('logs when creating a user', () => {
    // Given
    const loggerMock = { log: vi.fn() };
    const { facade } = setup(loggerMock);

    // When
    const user = facade.createUser('Alice');

    // Then
    expect(loggerMock.log).toHaveBeenCalledWith('create:Alice');
  });
});</code></pre>
            <pre><code class="language-ts">class Logger {
  log(_msg: string) {}
}

@Injectable({providedIn: 'root'})
export class UserService {
  logger = inject(Logger);
  createUser(name: string) { this.logger.log(`create:${name}`); }
}</code></pre>
          </div>
        </section>

        <section data-background-image="../assets/fond-blanc.png">
          <h3>Tester un service (DI + mocks)</h3>

          <div class="col-2" style="height: 550px">
            <pre
              style="width: 1050px"
            ><code class="language-ts">describe('UserService', () => {

  function setup(loggerMock: Logger) {                  // fonction setup pour configurer l'environnement de test
    await TestBed.configureTestingModule({              // (On peut aussi passer par un beforeEach
      providers: [                                      // mais faudra d√©clarer des variables interm√©diaires)
        { provide: Logger, useValue: loggerMock },      // ici on inject le mock de Logger
      ],
    });
    return TestBed.inject(UserService)                  // Et on cr√©er le service sur la base de l'environnement de test 
  }

  it('logs when creating a user', () => {               // d√©but du test
    // Given
    const loggerMock = { log: vi.fn() };                // Cr√©ation du mock de logger avec vitest 
    const { userService } = setup(loggerMock);          // Cr√©ation du service √† tester 

    // When
    const user = userService.createUser('Alice');       // Appel de la fonction test√©

    // Then
    expect(loggerMock.log).toHaveBeenCalledWith('create:Alice');  // Assertions
  });
});</code></pre>
          </div>
        </section>

        <section
          data-background-image="../assets/fond-blanc.png"
          style="zoom: 0.8"
        >
          <h3>Tester l'HTTP : HttpTestingController</h3>
          <p>
            On intercepte les requ√™tes et on "flush" une r√©ponse mock√©e, sans
            serveur r√©el
          </p>

          <pre
            style="height: 750px"
          ><code class="language-ts">@Injectable({providedIn: 'root'})
class UserService {
  private http = inject(HttpClient);
  getUsers() { return this.http.get&lt;User[]&gt;('/api/users'); }
}

describe('UserService', () => {
  let userService: UserService;               // Quand on utilise beforeEach il faut des var interm√©diaires

  beforeEach(async () => {
     TestBed.configureTestingModule({
      providers: [
        UserService,
        provideHttpClient(),                  // Comme dans main.ts il ce provide pour faire des appels HTTP 
        provideHttpClientTesting(),           // + un service fourni par angular pour les tests HTTP
      ],
    });
    userService = TestBed.inject(UserService);
  });

  it('mocks GET /api/users', () => {
    const httpMock = TestBed.inject(HttpTestingController);  // service permettant les mock HTTP

    let received: any;
    api.getUsers().subscribe(data => received = data);

    const req = httpMock.expectOne('/api/users');            // 
    expect(req.request.method).toBe('GET');                  // D√©finition de ce que va retourner l'API
    req.flush([{ id: 1, name: 'Alice' }]);                   //

    expect(received[0].name).toBe('Alice');

    httpMock.verify();                                       // A la fin on verifie que ca a bien √©t√© appel√©
  });
});</code></pre>
        </section>

        <section data-background-image="../assets/fond-blanc.png">
          <h3>Tester un composant : ComponentFixture</h3>
          <p>
            Un composant = classe + template : on teste l'int√©gration des 2 via
            le DOM
          </p>

          <pre><code class="language-ts">@Component({selector: 'app-counter',
  template: `
    <p data-testid="value">{{ value() }}</p>
    <button (click)="inc()">+</button>
  `,
})
class CounterComponent {
  value = signal(0);
  inc() { this.value.update(v => v + 1); }
}

describe('CounterComponent', () => {
  it('increments value on click', async () => {
    await TestBed.configureTestingModule({
      imports: [CounterComponent],
    }).compileComponents();

    const fixture = TestBed.createComponent(CounterComponent);
    fixture.detectChanges();

    const btn: HTMLButtonElement = fixture.nativeElement.querySelector('button');
    btn.click();
    fixture.detectChanges();

    const valueEl: HTMLElement = fixture.nativeElement.querySelector('[data-testid="value"]');
    expect(valueEl.textContent?.trim()).toBe('1');
  });
});</code></pre>
        </section>

        <section
          data-background-image="../assets/fond-blanc.png"
          style="zoom: 0.9"
        >
          <h2>TP18</h2>
          <ul>
            <li>Tout tester</li>
            <li>
              Installer:
              <pre><code>npm install --save-dev @vitest/browser-playwright playwright</code></pre>
            </li>
            <li>
              Modifier dans angular.json
              <pre><code>"test": {
  "builder": "@angular/build:unit-test",
  "options": {
    "browsers": ["chromium"]
  }
}</code></pre>
            </li>
            <li>
              Lancer:
              <pre><code>npx playwright install</code></pre>
            </li>
            <li>
              Tester:
              <ul>
                <li>DetailPersonneAvecService</li>
                <li>PostService</li>
                <li>ChiffreLePlusGrand</li>
              </ul>
            </li>
          </ul>
        </section>

        <section data-background-image="../assets/fond-bienvenue.png">
          <h1 style="margin-top: 1.5em; margin-bottom: 0.8em">
            Bravo et merci
          </h1>
          <div style="display: flex; justify-content: center; padding: 0">
            <app-plan completed="18" style="font-size: 0.4em"></app-plan>
          </div>
        </section>

        <section data-background-image="../assets/fond-blanc.png">
          <h3>Bonne pratiques: organisation du dossier app/</h3>
          <pre><code class="language-text">
tp6
...
‚îú‚îÄ src
‚îÇ  ‚îú‚îÄ app
‚îÇ  ‚îÇ  ‚îú‚îÄ core/                        // services singleton, logique transverse
‚îÇ  ‚îÇ  ‚îÇ  ‚îú‚îÄ services/
‚îÇ  ‚îÇ  ‚îÇ  ‚îî‚îÄ guards/
‚îÇ  ‚îÇ  ‚îú‚îÄ features/                    // domaines fonctionnels (lazy loading)
‚îÇ  ‚îÇ  ‚îÇ  ‚îî‚îÄ user/
‚îÇ  ‚îÇ  ‚îÇ     ‚îú‚îÄ user.routes.ts
‚îÇ  ‚îÇ  ‚îÇ     ‚îî‚îÄ user.component.ts
‚îÇ  ‚îÇ  ‚îú‚îÄ shared/                      // composants et utilitaires r√©utilisables
‚îÇ  ‚îÇ  ‚îÇ  ‚îú‚îÄ components/
‚îÇ  ‚îÇ  ‚îÇ  ‚îî‚îÄ pipes/
‚îÇ  ‚îÇ  ‚îú‚îÄ app.routes.ts                // routage principal 
‚îÇ  ‚îÇ  ‚îî‚îÄ app.component.ts             // composant racine  
...
  </code></pre>
        </section>
      </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/reveal.js/dist/reveal.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/reveal.js/plugin/highlight/highlight.js"></script>

    <script>
      Reveal.initialize({
        hash: true,
        slideNumber: true,
        plugins: [RevealHighlight],
      });
    </script>
  </body>
</html>
